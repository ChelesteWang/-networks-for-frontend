## 应用层协议

HTTP 是最常见到的应用层协议之一

# HTTP 协议

## 1. HTTP 的特点和缺点

**特点**：`无连接`、`无状态`、`灵活`、`简单快速`

- **无连接**：每一次请求都要连接一次，请求结束就会断掉，不会保持连接
- **无状态**：每一次请求都是独立的，请求结束不会记录连接的任何信息(**提起裤子就不认人的意思)**，减少了网络开销，这是`优点也是缺点`
- **灵活**：通过http协议中头部的`Content-Type`标记，可以传输任意数据类型的数据对象(文本、图片、视频等等)，非常灵活
- **简单快速**：发送请求访问某个资源时，只需传送请求方法和URL就可以了，使用简单，正由于http协议简单，使得http服务器的程序规模小，因而通信速度很快

**缺点**：`无状态`、`不安全`、`明文传输`、`队头阻塞`

- **无状态**：请求不会记录任何连接信息，没有记忆，就无法区分多个请求发起者身份是不是同一个客户端的，意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大
- **不安全**：`明文传输`可能被窃听不安全，缺少`身份认证`也可能遭遇伪装，还有缺少`报文完整性验证`可能遭到篡改
- **明文传输**：报文(header部分)使用的是明文，直接将信息暴露给了外界，`WIFI陷阱`就是复用明文传输的特点，诱导你连上热点，然后疯狂抓取你的流量，从而拿到你的敏感信息
- **队头阻塞**：开启`长连接`(下面有讲)时，只建立一个TCP连接，同一时刻只能处理一个请求，那么当请求耗时过长时，其他请求就只能阻塞状态(如何解决下面有讲)

## 2. HTTP 报文结构是怎样的

**http报文**：由`请求报文`和`响应报文`组成

**请求报文**：由`请求行`、`请求头`、`空行`、`请求体`四部分组成

**响应报文**：由`状态行`、`响应头`、`空行`、`响应体`四部分组成

- **请求行**：包含http方法，请求地址，http协议以及版本
- **请求头/响应头**：就是一些key:value来告诉服务端我要哪些内容，要注意什么类型等
- **空行**：用来区分首部与实体，因为请求头都是key:value的格式，当解析遇到空行时，服务端就知道下一个不再是请求头部分，就该当作请求体来解析了
- **请求体**：请求的参数
- **状态行**：包含http协议及版本、数字状态码、状态码英文名称
- **响应体**：服务端返回的数据

请求行：

[](https://camo.githubusercontent.com/02c7c1b8cb814b9bfee6915695538a9cbd92c3d04054badc2522235e406dee02/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f35306561356636323037316634613132613365373534376661363338373132632e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a484a766157527a5957357a5a6d467362474a685932732c736861646f775f35302c746578745f51314e4554694241355a7947355a79474d44453d2c73697a655f32302c636f6c6f725f4646464646462c745f37302c675f73652c785f3136)

状态行：

[](https://camo.githubusercontent.com/03bce5a99f89bce3b3f881c8ba1ee83bda72024d82432ab22649544acbd75606/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f61633765323631363633646334393939613839373634653966353638613064392e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a484a766157527a5957357a5a6d467362474a685932732c736861646f775f35302c746578745f51314e4554694241355a7947355a79474d44453d2c73697a655f31372c636f6c6f725f4646464646462c745f37302c675f73652c785f3136)

## 3. 常见的HTTP请求头和响应头

## HTTP Request Header 常见的请求头

- **Accept**: 浏览器能够处理的内容类型
- **Accept-Charset**:浏览器能够显示的字符集
- **Accept-Encoding**：浏览器能够处理的压缩编码
- **Accept-Language**：浏览器当前设置的语言
- **Connection**：浏览器与服务器之间连接的类型
- **Cookie**：当前页面设置的任何Cookie
- **Host**：发出请求的页面所在的域
- **Referer**：发出请求的页面的URL
- **User-Agent**：浏览器的用户代理字符串

[](https://camo.githubusercontent.com/c5a1a3c13cfeec576185cd1ec5e9ba850b854f30f179960903305a57af366b34/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f31646531646331376535643234373036616161363334353461326662373230392e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a484a766157527a5957357a5a6d467362474a685932732c736861646f775f35302c746578745f51314e4554694241355a7947355a79474d44453d2c73697a655f32302c636f6c6f725f4646464646462c745f37302c675f73652c785f3136)

## HTTP Responses Header 常见的响应头

- **Date**：表示消息发送的时间，时间的描述格式由rfc822定义
- **server**: 服务器名称
- **Connection**：浏览器与服务器之间连接的类型
- **Cache-Control**：控制HTTP缓存
- **content-type**: 表示后面的文档属于什么MIME类型
- **Pragma**：只有一个属性值，就是 no-cache ，效果和 Cache-Control 中的 no-cache 一致，不使用强缓存

[](https://camo.githubusercontent.com/c5a1a3c13cfeec576185cd1ec5e9ba850b854f30f179960903305a57af366b34/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f31646531646331376535643234373036616161363334353461326662373230392e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a484a766157527a5957357a5a6d467362474a685932732c736861646f775f35302c746578745f51314e4554694241355a7947355a79474d44453d2c73697a655f32302c636f6c6f725f4646464646462c745f37302c675f73652c785f3136)

## 4. HTTP 有哪些请求方法

`http/1.1`规定了以下请求方法(**注意，都是大写**):

- **GET**: 通常用来获取资源
- **HEAD**: 获取资源的元信息
- **POST**: 提交数据，即上传数据
- **PUT**: 修改数据
- **DELETE**: 删除资源(几乎用不到)
- **CONNECT**: 建立连接隧道，用于代理服务器
- **OPTIONS**: 列出可对资源实行的请求方法，用来跨域请求
- **TRACE**: 追踪请求-响应的传输路径

## 5. GET和POST请求的区别

- 从**缓存**的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。
- 从**编码**的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。
- 从**参数**的角度，GET 一般放在 URL 中，因此不安全，POST 放在`Request body`请求体中，更适合传输敏感信息。
- 从**幂等性**的角度，`GET`是**幂等**的，而`POST`不是。(在编程中一个幂等操作的特点是其任意多次执行一个方法所产生的影响均与一次执行的影响相同)
- 从**TCP**的角度，GET 请求会产生一个TCP数据包，把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包。GET浏览器把`http header`和data一起发出去，响应成功200，POST先发送header，响应100 continue，再发送data，响应成功200。(并不是所有的浏览器都会发送两次数据包，Firefox就发送一次，它的 POST 请求只发一个 TCP 包)

## 6. PUT和POST请求的区别

**PUT** 和 **POST** 都有更改指定URI的语义，但PUT被定义为幂等的方法，而POST则不是，多次调用会产生不同的结果。也就是说：

PUT请求：如果两个请求相同，后一个请求会把第一个请求覆盖掉。（**所以PUT用来改资源**）

POST请求：后一个请求不会把第一个请求覆盖掉。（**所以Post用来增资源**）

## 7. OPTIONS请求方法的使用场景

OPTIONS请求方法的**主要用途**有两个：

- 获取服务器支持的所有HTTP请求方法；
- 用来检查访问权限。例如：在进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。

## 8. 常见 HTTP 状态码

**`1xx`: 指示信息**——表示**请求已接收，继续处理**

**`2xx`: 成功**——表示**请求成功处理完毕**

**`3xx`: 重定向**——表示**要完成请求必须进行进一步操作**

**`4xx`: 客户端错误**——表示**请求有语法错误或请求无法实现**

**`5xx`: 服务端错误**——表示**服务器未能实现合法的请求**

常见状态码：

| 状态码 | 描述  |
| --- | --- |
| 100 | **Continue** 继续。客户端应继续其请求 |
| 101 | **Switching Protocols** 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议。如果服务器同意变更，就会发送状态码 101。 |
| 200 | **OK** 请求成功。通常在响应体中放有数据。 |
| 204 | **No Content** 含义与 200 相同，但响应头后没有 body 数据。 |
| 206 | **Partial Content** 已完成指定范围的请求(带Range头的GET请求)，场景如video,audio播放文件较大,文件分片和断点续传时 |
| 301 | **Moved Permanently** 永久重定向 |
| 302 | **Found** 临时重定向 |
| 304 | **Not Modified** 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。可以使用缓存的资源，不用在服务器获取。当协商缓存命中时会返回这个状态码。 |
| 400 | **Bad Request** 请求有语法错误 |
| 401 | **Unauthorized** 没有权限访问 |
| 403 | **Forbidden** 服务器理解请求客户端的请求，但是拒绝执行此请求。这实际上并不是请求报文出错，而是服务器禁止访问，原因有很多，比如法律禁止、信息敏感。 |
| 404 | **Not Found** 请求资源不存在 |
| 408 | **Request Time-out** 服务器等待客户端发送的请求时间过长，超时 |
| 500 | **Internal Server Error** 服务器内部错误，无法完成请求 |
| 501 | **Not Implemented** 表示客户端请求的功能还不支持，无法完成请求 |
| 503 | **Service Unavailable** 请求未完成，因服务器过载、宕机或维护等 |

## 9. 详细描述一下 301 和 302 状态码

**301 Moved Permanently 永久重定向：**

301重定向是网页更改地址后对搜索引擎友好的最好方法，只要不是暂时搬移的情况,都建议使用301来做转址。

**302 Found 临时重定向：**

302状态码应用的典型场景是服务器页面路径的重新规划。

常见场景有百度，知乎、简书等等。比如说我们要在百度进入菜鸟教程，搜索出来后有一系列的列表，我们可以选择一个去进行一个点击。点击的那个不会直接进入菜鸟教程，而是先跳转到百度设置的一个临时地址，之后再跳转到菜鸟教程真实的地址。

## 10. 为什么需要 持久连接

**HTTP协议的初始版本中，每进行一次HTTP通信就要断开一次TCP连接。**以当年的通信情况来说，因为都是些容量很小的文本传输，所以即使这样也没有多大问题。可随着 HTTP 的 普及，文档中包含大量图片的情况多了起来。比如，使用浏览器浏览一个包含多张图片的 HTML 页面时，在发送请求访问 HTML 页面资源的同时，也会请 求该 HTML 页面里包含的其他资源。因此，**每次的请求都会造成无谓的 TCP 连接建立和断开，增加通信量的 开销。**

[](https://camo.githubusercontent.com/989abe71f7a2d4c68ffda3eb1f263ad3c32612836ab6e63c87fb030e0027f508/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f35613464646163353061333034303965616564396235646137336630363032352e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a484a766157527a5957357a5a6d467362474a685932732c736861646f775f35302c746578745f51314e4554694241355a7947355a79474d44453d2c73697a655f32302c636f6c6f725f4646464646462c745f37302c675f73652c785f3136)

## 11. 持久连接 的特点

为解决上述 TCP 连接的问题，HTTP/1.1 和一部分的 HTTP/1.0 想出了持久连接（HTTP Persistent Connections，也称为 HTTP keep-alive 或 HTTP connection reuse）的方法。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态。

[](https://camo.githubusercontent.com/429eb99ae75de6876fc8293dbecf44a36473c44f98699b14ff123fef5b7913ec/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f31313866613330656132643834346238386138663031663835623761303235652e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a484a766157527a5957357a5a6d467362474a685932732c736861646f775f35302c746578745f51314e4554694241355a7947355a79474d44453d2c73697a655f32302c636f6c6f725f4646464646462c745f37302c675f73652c785f3136)

**持久连接的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。另外， 减少开销的那部分时间，使 HTTP 请求和响应能够更早地结束，这样 Web 页面的显示速度也就相应提高了。** 在 HTTP/1.1 中，所有的连接默认都是持久连接，但在 HTTP/1.0 内并未标准化。虽然有一部分服务器通过非 标准的手段实现了持久连接，但服务器端不一定能够支持持久连接。毫无疑问，除了服务器端，客户端也需 要支持持久连接。

## 12. HTTP管线化

持久连接使得多数请求以管线化（pipelining）方式发送成为可能。

HTTP管线化是将多个HTTP要求（request）整批提交的技术，而在传送过程中不需先等待服务端的回应。管线化机制须通过永久连接（persistent connection）完成，仅HTTP/1.1支持此技术（HTTP/1.0不支持），并且只有GET和HEAD要求可以进行管线化，而POST则有所限制。此外，初次创建连接时也不应启动管线机制，因为对方（服务器）不一定支持HTTP/1.1版本的协议。

[](https://camo.githubusercontent.com/59677868e82ed971fda0243fae5d9622b4fcdf7a5116c58ec6b242180dabc2c1/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f37333535303738643030306534653661393430323963393334656365396130322e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a484a766157527a5957357a5a6d467362474a685932732c736861646f775f35302c746578745f51314e4554694241355a7947355a79474d44453d2c73697a655f32302c636f6c6f725f4646464646462c745f37302c675f73652c785f3136)

## 13. 对keep-alive的理解

HTTP1.0 中默认是在每次请求/应答，客户端和服务器都要新建一个连接，完成之后立即断开连接，这就是**短连接**。当使用Keep-Alive模式时，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接，这就是**长连接**。其使用方法如下：

- HTTP1.0版本是默认没有Keep-alive的（也就是默认会发送keep-alive），所以要想连接得到保持，必须手动配置发送`Connection: keep-alive`字段。若想断开keep-alive连接，需发送`Connection:close`字段；
- HTTP1.1规定了默认保持长连接，数据传输完成了保持TCP连接不断开，等待在同域名下继续用这个通道传输数据。如果需要关闭，需要客户端发送`Connection：close`首部字段。

**开启Keep-Alive的优点：**

- 较少的CPU和内存的使⽤（由于同时打开的连接的减少了）；
- 允许请求和应答的HTTP管线化；
- 降低拥塞控制 （TCP连接减少了）；
- 减少了后续请求的延迟（⽆需再进⾏握⼿）；
- 报告错误⽆需关闭TCP连；

**开启Keep-Alive的缺点：**

- 长时间的Tcp连接容易导致系统资源无效占用，浪费系统资源。

## 14. HTTP 1.0 和 HTTP 1.1 之间有哪些区别？

- **连接方面**，http1.0 默认使用非持久连接，而 http1.1 默认使用持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。
- **资源请求方面**，在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
- **缓存方面**，在 http1.0 中主要使用 header 里的 If-Modified-Since、Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。
- http1.1 中**新增了 host 字段**，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，这样就可以将请求发往到同一台服务器上的不同网站。
- http1.1 相对于 http1.0 还**新增了很多请求方法**，如 PUT、HEAD、OPTIONS 等。

## 15. 页面有多张图片，HTTP是怎样的加载表现？

- 在`HTTP 1`下，浏览器对一个域名下最大TCP连接数为6，所以会请求多次。可以用多域名部署解决。这样可以提高同时请求的数目，加快页面图片的获取速度。
- 在`HTTP 2`下，可以一瞬间加载出来很多资源，因为，HTTP2支持多路复用，可以在一个TCP连接中发送多个HTTP请求。

## 16. HTTP协议的性能

HTTP 协议是基于 TCP/IP，并且使用了 **请求-应答** 的通信模式，所以性能的关键就在这两点里。

### 长连接

HTTP协议有两种连接模式，一种是持续连接，一种非持续连接。

（1）非持续连接指的是服务器必须为每一个请求的对象建立和维护一个全新的连接。

（2）持续连接下，TCP 连接默认不关闭，可以被多个请求复用。采用持续连接的好处是可以避免每次建立 TCP 连接三次握手时所花费的时间。

对于不同版本的采用不同的连接方式：

- 在`HTTP/1.0` 每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无畏的 TCP 连接建立和断开，增加了通信开销。该版本使用的非持续的连接，但是可以在请求时，加上 Connection: keep-a live 来要求服务器不要关闭 TCP 连接。
- 在`HTTP/1.1` 提出了 **长连接** 的通信方式，也叫 **持久连接** 。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。该版本及以后版本默认采用的是持续的连接。**目前对于同一个域，大多数浏览器支持同时建立 6 个持久连接。**

[](https://camo.githubusercontent.com/31f37314a2669da0aa1ce08acf39ee01e832f50449c1660b2186139edf677807/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f62366161663463316561346634623332396262336535636237666533353366352e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a484a766157527a5957357a5a6d467362474a685932732c736861646f775f35302c746578745f51314e4554694241355a7947355a79474d44453d2c73697a655f32302c636f6c6f725f4646464646462c745f37302c675f73652c785f3136)

### 管道网络传输

HTTP/1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。

管道（pipeline）网络传输是指：可以在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。但是服务器还是按照顺序回应请求。如果前面的回应特别慢，后面就会有许多请求排队等着。这称为队头堵塞。

### 队头堵塞

HTTP 传输的报文必须是一发一收，但是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。这就是HTTP队头阻塞问题。

### 队头阻塞的解决方案

（1）并发连接：对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。

（2）域名分片：将域名分出很多二级域名，它们都指向同样的一台服务器，能够并发的长连接数变多，解决了队头阻塞的问题。
